{"version":3,"sources":["../../src/core/Tokenizer.ts"],"names":["WHITESPACE_REGEX","NULL_REGEX","toCanonicalKeyword","text","toUpperCase","Tokenizer","cfg","tokens","tokenType","input","getTokenOnFirstMatch","type","regex","REGEX_MAP","transform","id","preprocess","specialWordCharsAll","Object","values","specialWordChars","join","TokenType","WORD","regexFactory","createWordRegex","STRING","createStringRegex","stringTypes","RESERVED_KEYWORD","createReservedWordRegex","reservedKeywords","RESERVED_DEPENDENT_CLAUSE","reservedDependentClauses","RESERVED_LOGICAL_OPERATOR","reservedLogicalOperators","RESERVED_COMMAND","reservedCommands","RESERVED_BINARY_COMMAND","reservedBinaryCommands","RESERVED_JOIN_CONDITION","reservedJoinConditions","OPERATOR","createOperatorRegex","operators","BLOCK_START","createParenRegex","blockStart","BLOCK_END","blockEnd","RESERVED_CASE_START","RESERVED_CASE_END","LINE_COMMENT","createLineCommentRegex","lineCommentTypes","BLOCK_COMMENT","NUMBER","PLACEHOLDER","EOF","INDEXED_PLACEHOLDER_REGEX","createPlaceholderRegex","indexedPlaceholderTypes","IDENT_NAMED_PLACEHOLDER_REGEX","namedPlaceholderTypes","STRING_NAMED_PLACEHOLDER_REGEX","createStringPattern","token","length","whitespaceBefore","getWhitespace","substring","getNextToken","Error","slice","push","matches","match","previousToken","matchToken","getPlaceholderToken","getReservedWordToken","placeholderTokenRegexMap","parseKey","v","getEscapedPlaceholderKey","key","quoteChar","reduce","acc","value","undefined","replace","RegExp","reservedTokenList","matchedToken"],"mappings":"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","sourcesContent":["import { equalizeWhitespace, escapeRegExp, id } from 'src/utils';\n\nimport * as regexFactory from './regexFactory';\nimport { type Token, TokenType } from './token';\n\nexport const WHITESPACE_REGEX = /^(\\s+)/u;\nconst NULL_REGEX = /(?!)/; // zero-width negative lookahead, matches nothing\n\nconst toCanonicalKeyword = (text: string) => equalizeWhitespace(text.toUpperCase());\n\n/** Struct that defines how a SQL language can be broken into tokens */\ninterface TokenizerOptions {\n  reservedKeywords: string[];\n  reservedCommands: string[];\n  reservedLogicalOperators?: string[];\n  reservedDependentClauses: string[];\n  reservedBinaryCommands: string[];\n  reservedJoinConditions?: string[];\n  stringTypes: regexFactory.StringPatternType[];\n  blockStart?: string[];\n  blockEnd?: string[];\n  indexedPlaceholderTypes?: string[];\n  namedPlaceholderTypes?: string[];\n  lineCommentTypes?: string[];\n  specialWordChars?: { prefix?: string; any?: string; suffix?: string };\n  operators?: string[];\n  preprocess?: (tokens: Token[]) => Token[];\n}\n\n/** Converts SQL language string into a token stream */\nexport default class Tokenizer {\n  REGEX_MAP: { [tokenType in TokenType]: RegExp };\n\n  INDEXED_PLACEHOLDER_REGEX?: RegExp;\n  IDENT_NAMED_PLACEHOLDER_REGEX?: RegExp;\n  STRING_NAMED_PLACEHOLDER_REGEX?: RegExp;\n\n  private preprocess = (tokens: Token[]) => tokens;\n\n  /**\n   * @param {TokenizerOptions} cfg\n   *  @param {string[]} cfg.reservedKeywords - Reserved words in SQL\n   *  @param {string[]} cfg.reservedDependentClauses - Words that following a specific Statement and must have data attached\n   *  @param {string[]} cfg.reservedLogicalOperators - Words that are set to newline\n   *  @param {string[]} cfg.reservedCommands - Words that are set to new line separately\n   *  @param {string[]} cfg.reservedBinaryCommands - Words that are top level but have no indentation\n   *  @param {string[]} cfg.reservedJoinConditions - ON and USING\n   *  @param {string[]} cfg.stringTypes - string types to enable - \"\", '', ``, [], N''\n   *  @param {string[]} cfg.blockStart - Opening parentheses to enable, like (, [\n   *  @param {string[]} cfg.blockEnd - Closing parentheses to enable, like ), ]\n   *  @param {string[]} cfg.indexedPlaceholderTypes - Prefixes for indexed placeholders, like ?\n   *  @param {string[]} cfg.namedPlaceholderTypes - Prefixes for named placeholders, like @ and :\n   *  @param {string[]} cfg.lineCommentTypes - Line comments to enable, like # and --\n   *  @param {string[]} cfg.specialWordChars - Special chars that can be found inside of words, like @ and #\n   *  @param {string[]} cfg.operators - Additional operators to recognize\n   *  @param {Function} cfg.preprocess - Optional function to process tokens before emitting\n   */\n  constructor(cfg: TokenizerOptions) {\n    if (cfg.preprocess) {\n      this.preprocess = cfg.preprocess;\n    }\n\n    const specialWordCharsAll = Object.values(cfg.specialWordChars ?? {}).join('');\n    this.REGEX_MAP = {\n      [TokenType.WORD]: regexFactory.createWordRegex(cfg.specialWordChars),\n      [TokenType.STRING]: regexFactory.createStringRegex(cfg.stringTypes),\n      [TokenType.RESERVED_KEYWORD]: regexFactory.createReservedWordRegex(\n        cfg.reservedKeywords,\n        specialWordCharsAll\n      ),\n      [TokenType.RESERVED_DEPENDENT_CLAUSE]: regexFactory.createReservedWordRegex(\n        cfg.reservedDependentClauses ?? [],\n        specialWordCharsAll\n      ),\n      [TokenType.RESERVED_LOGICAL_OPERATOR]: regexFactory.createReservedWordRegex(\n        cfg.reservedLogicalOperators ?? ['AND', 'OR'],\n        specialWordCharsAll\n      ),\n      [TokenType.RESERVED_COMMAND]: regexFactory.createReservedWordRegex(\n        cfg.reservedCommands,\n        specialWordCharsAll\n      ),\n      [TokenType.RESERVED_BINARY_COMMAND]: regexFactory.createReservedWordRegex(\n        cfg.reservedBinaryCommands,\n        specialWordCharsAll\n      ),\n      [TokenType.RESERVED_JOIN_CONDITION]: regexFactory.createReservedWordRegex(\n        cfg.reservedJoinConditions ?? ['ON', 'USING'],\n        specialWordCharsAll\n      ),\n      [TokenType.OPERATOR]: regexFactory.createOperatorRegex('+-/*%&|^><=.,;[]{}`:$@', [\n        '<>',\n        '<=',\n        '>=',\n        '!=',\n        ...(cfg.operators ?? []),\n      ]),\n      [TokenType.BLOCK_START]: regexFactory.createParenRegex(cfg.blockStart ?? ['(']),\n      [TokenType.BLOCK_END]: regexFactory.createParenRegex(cfg.blockEnd ?? [')']),\n      [TokenType.RESERVED_CASE_START]: /^(CASE)\\b/iu,\n      [TokenType.RESERVED_CASE_END]: /^(END)\\b/iu,\n      [TokenType.LINE_COMMENT]: regexFactory.createLineCommentRegex(cfg.lineCommentTypes ?? ['--']),\n      [TokenType.BLOCK_COMMENT]: /^(\\/\\*[^]*?(?:\\*\\/|$))/u,\n      [TokenType.NUMBER]:\n        /^(0x[0-9a-fA-F]+|0b[01]+|(-\\s*)?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+(\\.[0-9]+)?)?)/u,\n      [TokenType.PLACEHOLDER]: NULL_REGEX, // matches nothing\n      [TokenType.EOF]: NULL_REGEX, // matches nothing\n    };\n\n    this.INDEXED_PLACEHOLDER_REGEX = regexFactory.createPlaceholderRegex(\n      cfg.indexedPlaceholderTypes ?? [],\n      '[0-9]*'\n    );\n    this.IDENT_NAMED_PLACEHOLDER_REGEX = regexFactory.createPlaceholderRegex(\n      cfg.namedPlaceholderTypes ?? [],\n      '[a-zA-Z0-9._$]+'\n    );\n    this.STRING_NAMED_PLACEHOLDER_REGEX = regexFactory.createPlaceholderRegex(\n      cfg.namedPlaceholderTypes ?? [],\n      regexFactory.createStringPattern(cfg.stringTypes)\n    );\n  }\n\n  /**\n   * Takes a SQL string and breaks it into tokens.\n   * Each token is an object with type and value.\n   *\n   * @param {string} input - The SQL string\n   * @returns {Token[]} output token stream\n   */\n  tokenize(input: string): Token[] {\n    const tokens: Token[] = [];\n    let token: Token | undefined;\n\n    // Keep processing the string until it is empty\n    while (input.length) {\n      // grab any preceding whitespace\n      const whitespaceBefore = this.getWhitespace(input);\n      input = input.substring(whitespaceBefore.length);\n\n      if (input.length) {\n        // Get the next token and the token type\n        token = this.getNextToken(input, token);\n        if (!token) {\n          throw new Error(`Parse error: Unexpected \"${input.slice(0, 100)}\"`);\n        }\n        // Advance the string\n        input = input.substring(token.text.length);\n\n        tokens.push({ ...token, whitespaceBefore });\n      }\n    }\n    return this.preprocess(tokens);\n  }\n\n  /** Matches preceding whitespace if present */\n  getWhitespace(input: string): string {\n    const matches = input.match(WHITESPACE_REGEX);\n    return matches ? matches[1] : '';\n  }\n\n  /** Curried function of `getTokenOnFirstMatch` that allows token type to be passed first */\n  matchToken =\n    (tokenType: TokenType) =>\n    (input: string): Token | undefined =>\n      this.getTokenOnFirstMatch({\n        input,\n        type: tokenType,\n        regex: this.REGEX_MAP[tokenType],\n        transform: id,\n      });\n\n  /** Attempts to match next token from input string, tests RegExp patterns in decreasing priority */\n  getNextToken(input: string, previousToken?: Token): Token | undefined {\n    return (\n      this.matchToken(TokenType.LINE_COMMENT)(input) ||\n      this.matchToken(TokenType.BLOCK_COMMENT)(input) ||\n      this.matchToken(TokenType.STRING)(input) ||\n      this.matchToken(TokenType.BLOCK_START)(input) ||\n      this.matchToken(TokenType.BLOCK_END)(input) ||\n      this.getPlaceholderToken(input) ||\n      this.matchToken(TokenType.NUMBER)(input) ||\n      this.getReservedWordToken(input, previousToken) ||\n      this.matchToken(TokenType.WORD)(input) ||\n      this.matchToken(TokenType.OPERATOR)(input)\n    );\n  }\n\n  /**\n   * Attempts to match a placeholder token pattern\n   * @return {Token | undefined} - The placeholder token if found, otherwise undefined\n   */\n  getPlaceholderToken(input: string): Token | undefined {\n    const placeholderTokenRegexMap: { regex: RegExp; parseKey: (s: string) => string }[] = [\n      // pattern for placeholder with identifier name\n      {\n        regex: this.IDENT_NAMED_PLACEHOLDER_REGEX ?? NULL_REGEX,\n        parseKey: v => v.slice(1),\n      },\n      // pattern for placeholder with string name\n      {\n        regex: this.STRING_NAMED_PLACEHOLDER_REGEX ?? NULL_REGEX,\n        parseKey: v =>\n          this.getEscapedPlaceholderKey({ key: v.slice(2, -1), quoteChar: v.slice(-1) }),\n      },\n      // pattern for placeholder with numeric index\n      {\n        regex: this.INDEXED_PLACEHOLDER_REGEX ?? NULL_REGEX,\n        parseKey: v => v.slice(1),\n      },\n    ];\n\n    return placeholderTokenRegexMap.reduce((acc, { regex, parseKey }) => {\n      const token = this.getTokenOnFirstMatch({\n        input,\n        regex,\n        type: TokenType.PLACEHOLDER,\n        transform: id,\n      });\n      return token ? { ...token, key: parseKey(token.value) } : acc;\n    }, undefined as Token | undefined);\n  }\n\n  getEscapedPlaceholderKey({ key, quoteChar }: { key: string; quoteChar: string }): string {\n    return key.replace(new RegExp(escapeRegExp('\\\\' + quoteChar), 'gu'), quoteChar);\n  }\n\n  /**\n   * Attempts to match a Reserved word token pattern, avoiding edge cases of Reserved words within string tokens\n   * @return {Token | undefined} - The Reserved word token if found, otherwise undefined\n   */\n  getReservedWordToken(input: string, previousToken?: Token): Token | undefined {\n    // A reserved word cannot be preceded by a '.'\n    // this makes it so in \"mytable.from\", \"from\" is not considered a reserved word\n    if (previousToken?.value === '.') {\n      return undefined;\n    }\n\n    // prioritised list of Reserved token types\n    const reservedTokenList = [\n      TokenType.RESERVED_CASE_START,\n      TokenType.RESERVED_CASE_END,\n      TokenType.RESERVED_COMMAND,\n      TokenType.RESERVED_BINARY_COMMAND,\n      TokenType.RESERVED_DEPENDENT_CLAUSE,\n      TokenType.RESERVED_LOGICAL_OPERATOR,\n      TokenType.RESERVED_KEYWORD,\n      TokenType.RESERVED_JOIN_CONDITION,\n    ];\n\n    return reservedTokenList.reduce(\n      (matchedToken: Token | undefined, tokenType) =>\n        matchedToken ||\n        this.getTokenOnFirstMatch({\n          input,\n          type: tokenType,\n          regex: this.REGEX_MAP[tokenType],\n          transform: toCanonicalKeyword,\n        }),\n      undefined\n    );\n  }\n\n  /**\n   * Attempts to match RegExp from head of input, returning undefined if not found\n   * @param {string} _.input - The string to match\n   * @param {TokenType} _.type - The type of token to match against\n   * @param {RegExp} _.regex - The regex to match\n   * @return {Token | undefined} - The matched token if found, otherwise undefined\n   */\n  getTokenOnFirstMatch({\n    input,\n    type,\n    regex,\n    transform,\n  }: {\n    input: string;\n    type: TokenType;\n    regex: RegExp;\n    transform: (s: string) => string;\n  }): Token | undefined {\n    const matches = input.match(regex);\n    if (matches) {\n      return {\n        type,\n        text: matches[1],\n        value: transform(matches[1]),\n      };\n    }\n    return undefined;\n  }\n}\n"],"file":"Tokenizer.js"}